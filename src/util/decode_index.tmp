
        // Scan 0:
        // * Determine which bits are significant (mask) for all items.
        // * Determine which bits have the same value for all items.

        let (first, rest) = src.split_first().unwrap();

        let mut prev = first.bits();        // bits of previous item
        let mut diff = T::Word::ZERO;       // bits that differ (1=different)
        let mut mask = first.mask() & care; // bits significant to all items

        for item in rest {
            let bits = item.bits();
            diff |= bits ^ prev;
            prev  = bits;
            mask &= item.mask();
        }

        /*

        // Choose a 'selector'
        //   -- a range of selective (significant and differing) bits.

        let (mask, pos, len) = Self::find_mask(mask & diff, Self::MAX_SEL_BITS);

        // If no selective range, a trie is impossible; use scan instead.
        // This branch also used for single items.

        if len == 0 {
            return Scan(src)
        }

        // Scan 1:
        // * Discover contiguous item ranges with same selector.

        let mut ranges = Vec::with_capacity(1 << len);
        {
            let mut start  = 0;
            let mut end    = 1;
            let mut prev   = first.bits() & mask;

            for item in rest {
                let bits = item.bits() & mask;
                let next = end + 1;

                if bits != prev {
                    ranges.push((start..end, prev));
                    start = end;
                    prev  = bits;
                }

                end = next;
            }
        }

        // Scan 2:
        // * 
        //
        // need: (sel) => (range, is_contig)


        // * Contiguous => trie; noncontiguous => scan.
        //
        //for (i, item) in src.iter().enumerate() {
        //    let sel = ((item.bits() & mask) >> pos).to_usize();
        //    {
        //        let range = &mut ranges[sel];
        //        if range.len() == 0 {
        //            *range = i..(i+1);
        //        } else if range.end + 1 == i {
        //            range.end = i;
        //        } else {
        //            panic!();
        //        }
        //    }
        //}

        let care = care & !mask; // for subnodes

        // Distribute items into bins by their selective bits.

        let mut bins = vec![Vec::new(); 1 << len];

        for &x in src {
            let i = ((x.bits() & mask) >> (pos as usize)).to_usize().unwrap();
            bins[i].push(x);
        }

        // Convert bins into nodes

        Self {
            nodes: bins
                .into_iter()
                .map(|items| Trie {
                    bits:    T::Word::ZERO, // TODO
                    mask:    T::Word::ZERO, // TODO
                    content: Content::Trie(Self::from_(&items[..], care)),
                })
                .collect()
        }
        */
